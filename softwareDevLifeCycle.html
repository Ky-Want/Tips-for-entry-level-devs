<!--
What is the Software Development Life Cycle?

The software development life cycle (SDLC) explains the different stages of software development. This framework is important because it covers the planning, building, deployment, and maintenance of the software. The SDLC delivers high-quality software by creating it in a systematic manner.
Proper planning is an essential aspect of the software development life cycle. From there, team members develop and execute plans into the software.





STAGES OF THE SOFTWARE DEVELOPMENT LIFE CYCLE
The need for software development methodologies dates back to the 1950s. At that time, words like “framework” and “approach” really didn’t exist in the context of software development.
Since then, software engineers have sought to create and implement development methods to accelerate software development. Now, the SDLC is used to reduce time-to-market while building an intuitive software for clients.

Today’s SDLC promotes:
*Individuals over processes and tools
*Adapting to new needs
*Working software over comprehensive documentation
*Customer collaboration

All software development life cycle models involve various stages. Although these strategies can vary from model to model, we’ll look at the following SDLC sequence:
Stage 1: Requirement gathering and analysis
Stage 2: Design
Stage 3: Implementation or coding
Stage 4: Testing
Stage 5: Deployment
Stage 6: Maintenance

Stage 1: Requirement gathering and analysis
In this stage, teams should collect all relevant information from the client. They use this information to develop the product, ensuring that they meet client expectations. Typically, the business analysts and project managers meet with the client to gather information.
This information includes:
*A description of what they want the software to be
*The end-user
*The purpose
Once they’ve gathered and understood the information, they should produce the software requirement specification (SDS) document.
From there, the software development team should receive this document and ask any questions. They will then pass on the document to the client. This way, the client can verify that the project is well-understood by the team and can hold on to the document for future reference.

Stage 2: Design
At this point, the requirements from the SRS document are referenced to create the software architecture. The project manager will decide on the approach that the team will take and outline a pricing model.

Stage 3: Implementation or coding
This phase begins after the developer receives the design document. At this point, the design is translated into source code. This is when software developers go in and implement the code.

Stage 4: Testing
Once the development team has started coding, they release modules. These modules are then rigorously tested. Issues and bugs are detected, and software developers are assigned areas to test. Testers reference the SRS document to confirm that the software matches client expectations. This process continues until the software is perfected.

Stage 5: Deployment
At this point, the software is deployed into production. In some cases, the client may request that the software goes through user acceptance testing (UAT). Regardless of whether the client elects UAT, they will decide whether the software meets their expectations in this step.

Stage 6: Maintenance
Following production, the development team will maintain the product. Sometimes, issues might arise during testing. At this point, the software developers can fix these issues. In some cases, a client might request additional features, which can be added as enhancements during this phase.





POPULAR SOFTWARE DEVELOPMENT LIFE CYCLE METHODS: CONCEPTS, PROS, AND CONS
Software development life cycle methods are continually evolving. Since its inception with the Waterfall model, the SDLC has changed to fit various scenarios. As a result, software development teams have multiple models to reference. Successful pieces of these models have been hybridized into newer, more refined models.
In this next section, we’ll break down some of the most common SDLC methodologies, explaining distinctions between the methods. All of these methods have found some level of success in the industry, but each brings its own pros and cons.

Popular SDLC models include:
Waterfall
Agile
Iterative and Incremental
Prototype
Spiral
V-Shaped





Waterfall
In the 1970s, the Waterfall model, also known as the linear sequential model, was created. This model focuses on an organized approach to project management.
This methodology focuses on receiving clear requirements from clients and stakeholders so that the development team can best accommodate their requests.  It requires clear milestones and explanations for team members from clients.
Before the development team can move on to another phase, they must complete the phase ahead of it.

Phases of the Waterfall method are as follows:
*Requirement analysis
*System design
*Implementation
*Testing
*Deployment
*Maintenance

Pros
Simple: This model is easily understood.
Phases: The Waterfall method has clear phases for development teams to follow. ‍
Manageable: Because each phase is so clearly defined, the project is easily manageable.

Cons
Time-consuming: Teams cannot move to another step until the previous phase has been completed.
Not adaptable: This project cannot be used for projects with nonspecific requirements. Clients must be incredibly clear with their requirements for this model to work. ‍
Not for short-term projects: Because of the nature of the phases, this model may not work well for projects that are short in duration.





Agile
The Agile model, which formally began in the 1990s, focuses on adaptability instead of strict requirements. An Agile approach to software development empowers teams to meet requirements in a flexible manner.
Agile is particularly helpful for remote teams, as it can be used to combat issues with time zones, communication problems, availability, and more.
Projects following the Agile method are broken into smaller incremental builds. These periods are referred to as sprints. Each sprint usually lasts somewhere between two to four weeks. At the beginning of each sprint, the development team meets with the client to outline the goals of that sprint, and then they develop and test code. Finally, they review the features with the client.

This method focuses on:
*Incremental improvements
*Customer feedback
*Sprints between two to four weeks
*Constant testing

Pros
Adaptability: Agile is incredibly flexible, allowing teams to adjust to changes in requirements.
Improved client satisfaction: Because there is near-constant communication, and clients are given a chance to provide feedback every step of the way, this method may produce higher degrees of client satisfaction.‍
Quickly add features: Since sprints generally last two to four weeks, features can be quickly added.

Cons
Requires experience: The Agile method requires very experienced team members.
Need for clarity: Clients need to be extremely clear with their expectations because there is no SDS documentation. ‍
No documentation: The Agile method focuses on software quality over documentation.





Iterative and Incremental
In 1975, the Iterative and Incremental model was established as an answer to the shortcomings of the Waterfall method. This model supports the development of a system through recurrent cycles and smaller subsets—iterative and incremental.
This model empowers teams to learn from the previous phases and improve on them in the next iteration. Simply put, this model divides a project into smaller, more manageable chunks.

These are the phases of the Iterative and Incremental model:
*Inception: This phase is when the requirements and scope of the project are discussed.  
*Elaboration: This phase is when the identified requirements from the inception phase are worked into the architecture of the product.
*Construction: This phase occurs when code is created through analysis, design, implementation, and testing. In this phase, the development team references the architecture to create the code.
*Transition: During this phase, the product is pushed to production.

Pros
Easily modified: The software can be easily adapted to fit new requirements since development occurs in smaller increments.
Identify risks: Because development occurs in iterations, risks can be identified early on and fixed if needed.
Bug detection: Issues can be identified and addressed before the project progresses. ‍
Manageable: Having the project broken up into smaller phases makes it easier to create, test, and manage the software.

Cons
Complete understanding: The development team must have complete knowledge of the product to divide and build it little by little.





Prototype
Development teams using the Prototype model create a prototype before coding the actual software. These models have limited functionalities and are somewhat inefficient compared to the actual software; however, they are valuable in understanding clients’ needs. Having a prototype of the software provides development teams with better client feedback. The client can voice their opinions, and the team can address their concerns before building the actual software.

Pros
Reduces cost: This model reduces the time it takes to develop the software because any defects are caught earlier, reducing the cost of the project.
Feedback: Development teams gain valuable insight from clients before they build the software. ‍
Catch errors: Building a prototype helps teams to identify missing requirements before the official build.

Cons
Potential to become complex: Since clients are active at every phase of this development, they could potentially change requirements. This could end up increasing the scope of the project, resulting in more money and time spent on the project.





Spiral
The Spiral model has both an iterative and a prototype approach to software development. Each phase in the Spiral model is followed by iterations. It follows a loop design, which represents the phases of the SDLC process.

The Spiral model occurs in four phases:
*Planning: This phase details client requirements. The development team creates specification documentation, which is used in the following phases.
*Risk analysis: During this phase, the development team addresses risks and analyzes them by building a prototype.
*Engineering: During this phase, the development team begins to code and test the software.
*Evaluation: In this phase, the project is handed over to the client. During this phase, the client assesses the software and creates plans for the next iteration.

Pros
Risk analysis: The development team performs risk analysis using prototype models. ‍
Flexible: Changes can be quickly made in the next iteration.

Cons
Large projects only: This model is designed and only works well in large projects. It cannot be scaled down for smaller projects. ‍
Costly: Because this model has the potential to have many iterations, it can add up and become quite costly.





V-Shaped
The V-Shaped model, or the Verification and Validation model, executes processes in a V-shaped sequential manner. Verification involves the static analysis technique (review) before code is produced. Validation is a more dynamic analysis technique, which tests on existing code.
This model works well for teams made up of members with the necessary technical expertise. The V-Shaped model is best for development teams that want to detect errors early on or before they cause problems. Teams should use this model when the client has clearly defined requirements.

Here are some key takeaways of the V-Shaped model:
*Best for small projects
*Needs clearly defined requirements
*Used in small projects

Pros
Track progress: Because of the phases in the V-Shaped model, it’s easy for project managers to track progress accurately.‍
Highly disciplined: This model requires that a phase be completed before the development team can move on to the next. Phases must be completed one at a time.

Cons
Not well suited for larger projects: Using this model for larger projects would be very complex, as it does not support the iteration of phases.
-->